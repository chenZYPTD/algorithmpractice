'''桶排序（Bucket Sort）是一种分布式排序算法，
它将元素分布到多个称为“桶”的容器中，
然后对每个桶内的元素进行排序，最后按顺序收集各个桶中的元素以获得排序后的列表。
桶排序特别适用于当输入数据均匀分布在一个范围内时的情况。
其基本步骤如下：

1、初始化桶：创建一定数量的桶，每个桶代表一个区间范围。这些区间范围应该是互不重叠的，并且覆盖整个输入数据的范围。

2、分配元素到桶中：遍历输入数据，根据元素值将每个元素分配到对应的桶中。元素分配到哪个桶通常由一个映射函数决定，这个函数基于元素值和桶的区间范围。

3、对每个桶内部进行排序：单独对每个桶内的元素进行排序。可以使用不同的排序算法来实现，例如快速排序、插入排序等。

4、收集桶中的元素：按顺序从每个桶中收集元素，这些收集起来的元素即为排序后的结果。

桶排序的时间复杂度分析相对复杂，因为它依赖于数据的分布、桶的数量和每个桶内使用的排序算法。
在最佳情况下，如果数据是均匀分布的，桶排序的时间复杂度可以达到O(n+k)，其中n是待排序元素的数量，k是桶的数量。
但是，在最坏的情况下，如果所有数据都分布到同一个桶中，那么其时间复杂度会退化为桶内排序算法的时间复杂度，如O(n^2)。
桶排序不是比较排序，它利用了元素值的额外信息，因此在适当的场景下可以超越比较排序算法的下界O(n log n)。
然而，桶排序的使用受限于输入数据的特性以及如何选择和实现桶的策略。
桶排序适合数字大、数字多的排序情况'''
def Bucket_Sort(a,bucketcount):#桶的个数
    min_value,max_value=min(a),max(a)
    #桶大小
    bucketsize=(max_value-min_value+1)//bucketcount#这里加个1是因为植树原理
    result=[[] for i in range(bucketcount+1)]#加一是因为上面是取整函数，以保证桶足够。
    for x in a:
        idx=(x-min_value)//bucketsize   #算出列表a中的x是处在第几个桶
        result[idx].append(x)           #然后放在对应的桶即可
    #每个桶单独排序，可以用其它排序算法，这里用默认排序
    ans = []
    for result_x in result:
        result_x.sort()  #或者直接sorted
        # 最后，我们串联所有的桶
        ans+=result_x
    return ans

n = int(input())
a = list(map(int, input().split()))
sorted_a=Bucket_Sort(a,min(n,10000))#这里要重新定义一个变量，因为函数的返回值才是被排序后的结果
print(' '.join(map(str,sorted_a)))