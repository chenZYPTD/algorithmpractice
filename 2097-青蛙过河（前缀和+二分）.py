#2097青蛙过河--前缀和+二分
#https://www.lanqiao.cn/problems/2097/learning/

n,x = map(int,input().split())
a= list(map(int,input().split()))
sum= [0]*n
    #首先处理一下，像这种需要计算连续数组值时使用前缀和是能够节省时间复杂度的，计算代码相对来说也比较简单
    #思路：创建一个比原数组多一个长度的全0数组，随后循环相加，这里要注意的是，循环从1开始，边界值在n
    #关于边界值为n的解释，我们创建了一个数组为n-1的列表H，实际上这个列表中的最后一项为n-2，同理，sum_H的最后一项
    #为n-1，所以为了防止越界，我们的边界值分别为1，n
for i in range(1,n):
    sum[i] = sum[i-1] + a[i-1]
    #检查部分为核心代码，这里要思考的是，我的跳跃能力满足什么条件时才能往返2*x次呢？
    #每次跳到一个石头上石头上的数字-1，我肯定是想跳到我能跳到的最远的或者最高的，用来保证我能跳回来
    #但是算法过于复杂，换个思路，当在我跳跃范围之内，所有石头的高度之和能够大于或者等于我跳2*x次不是一样吗
    #两个思路的差异在于，第一个思路太偏向于单个石头，而第二个思路从跳跃范围之和考虑，使用前缀和就能完美解决
def check(y):
        #搞清楚边界是关键，用除法去找整段太麻烦，你要想一想，如果你要知道你总共有几段跳跃距离，你只要知道你
        #最后一步落在哪里就行了，显然是落在n-y-1这个石头上
    for i in range(n-y):
            #左右边界其实很好确定
            #左边界当然是第i块石头，因为我每次检查的就是我的跳跃范围内的石头之和是否大于2*x，所以我的
            #右边界当然是i+y，只要在这个范围内的石头高度之和大于2*x，那在y跳跃能力之下是一定可以上x次课的
        if sum[i+y]-sum[i]<2*x:
            return False
    return True
    #使用二分法将符合条件的最小跳跃值计算出来
l,r = 1,n
res = -1
while l<=r:
    mid = (l+r) // 2
    if check(mid):
        res = mid
        r = mid - 1
    else:
        l = mid + 1
print(res)
