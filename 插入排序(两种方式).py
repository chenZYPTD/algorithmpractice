'''以下内容来自ChatGPT
插入排序（Insertion Sort）是一种简单直观的排序算法，
它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），
因其简单易懂和实现方便，在数据量小的时候尤其高效，如数据基本有序的情况下，效率更是非常高。
'''
'''
工作原理
从第一个元素开始，该元素可以认为已经被排序；
取出下一个元素，在已经排序的元素序列中从后向前扫描；
如果该元素（已排序）大于新元素，将该元素移到下一位置；
重复步骤3，直到找到已排序的元素小于或等于新元素的位置；
将新元素插入到该位置后；
重复步骤2~5。
'''
'''
示例
假设有一组数字：5, 2, 4, 6, 1, 3，我们来逐步演示插入排序的过程：

初始状态：5, 2, 4, 6, 1, 3
第一次插入：2, 5, 4, 6, 1, 3（2插入到5前面）
第二次插入：2, 4, 5, 6, 1, 3（4插入到2和5之间）
第三次插入：2, 4, 5, 6, 1, 3（6比5大，保持位置）
第四次插入：1, 2, 4, 5, 6, 3（1插入到最前面）
第五次插入：1, 2, 3, 4, 5, 6（3插入到2和4之间）
复杂度分析
时间复杂度：最好情况O(n)，平均情况和最坏情况O(n^2)，其中n是数组的长度。
空间复杂度：O(1)，因为只需要一个额外的存储空间。
插入排序适合于小规模数据或基本有序的数据，对于大规模乱序数据，插入排序的效率会大大降低。
'''

#插入排序，authentic
n = int(input())
nums = list(map(int, input().split()))

for i in range(1, n):#我们默认第一个元素是被排序的，因此后面在排的时候，前面的已经默认排了，
                     #因此不会出现前面有2个比目标数字更大的数字。
    j = i - 1        #从后往前比，如果前面的比选取的这个更大那么就把前面的集体向后挪，直到这个存在没有
    current_num = nums[i]
    while j >= 0 and nums[j] > current_num:#如果current_num前面出现了更大的项，那就向后挪一格，相当于交换
        nums[j + 1] = nums[j]              #由于前面已经是排序好了的，所以就算前面所有数字都比current_num大，
        j = j - 1                          #也可以随着j变小被一个一个往后挪。

    nums[j + 1] = current_num  #最后，将 current_num 插入到正确的位置上，这个位置就是 j + 1(即nums[i])
print(' '.join(map(str,nums)))

# #插入排序(待分析)
# n=int(input())
# a=list(map(eval,input().split(' ')))#对于第i个数字，在区间[0,i-1]中从后往前找对应插入的位置
# for i in range(1,n):
#                          '''此时我们先认为第一位是排好的，
#                          若后面存在比第一位更小的数字（设其为a[k]），
#                          让a[0:k]全部往后挪一位即可(整体挪)'''
# value=a[i]
# insert_idx=0
# for j in range(i-1,-1,-1):
#     if a[j]>value:
#     #往后挪
#         a[j+1]=a[j]
#     else:
#         insert_idx=j+1
#     a[insert_idx]=value#更新最小值序列和其对应的索引
# print(' '.join(map(str,a)))

